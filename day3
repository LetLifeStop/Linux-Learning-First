man man 帮助手册

alias 查看linux的标准命令
 alias ls 对应的封装函数
echo str
  把指定的字符串输出到终端上
echo $PATH
  打印环境变量（$ 从变量中取值）
sudo poweroff 关机
sudo reboot 重新启动
vim 是从vi发展过来的文本编译器
  前提：安装了vim
 工作模式：
  1，命令模式 -- 打开文件之后，默认进入命令模式
  2，编辑模式 -- 需要输入一些命令，切换到编辑模式
  3.末行模式  -- 在末行模式下可以输入一些命令
 三种模式的转换：
   命令模式 （i,a,o,s,I,A,O,S）-> 文本模式
   文本模式 （ESC键）-> 命令模式
   文本模式 （X） -> 末行模式
   命令模式（:冒号）-> 末行模式
   末行模式（按两次ESC键）->命令模式
   注意：末行模式无法直接到达文本模式，需要通过命令模式进行转换
    :w 保存当前文件（按回车之后自动切换到命令模式）
 文本的编译：
  光标的移动：
   l 往后移动光标 
   h 往前移动光标
   j 往下移动光标
   k 往上移动光标
   0 移动到当前行的行首
   $ 移动到当前行的行末
   gg（g按两次） 移动到当前文件的头部
   GG（G按两次） 移动到当前文件的尾部
   500G 移动到第500行
   命令模式下
   {
   在vi中，删除的真正功能其实是剪切走这一部分.(p为粘贴到当前行的下面，可以通过这个进行检验；P粘贴到光标所在行)
   所以在vim中，剪切 == 删除
   x 删除光标所在的字符
   X 删除光标前面的字符
   dw 删除当前这个字符（把光标移动到这个单词的最前面）
   d0 从当前位置开始删，一直删除到行首
   dd 删除当前行的内容
   4dd 从当前行再删除n行
   u 撤销操作
   ctrl + r 反撤销
   yy 复制
   4yy 复制4行
   v 切换到可视模式，结合光标移动的操作（复制内容的时候，只包含字符）
   （可视模式中，y是复制；d是删除）
   /要查找的内容（n 可以转圈的查询，往下找；N 往上找） 查找单词
   ? 要查找的内容   查找单词
   这两个的区别：/ 是先往下查询，然后返回到头部；？是先往上查询，然后返回到底部.
   选定单词中的一个字母 按 # 就会找到所有的这个单词  查找指定的单词 
   遍历时候的快捷键 N/n 上/下
   r 先选定这个字符，然后点击r，再输入要转换成哪个字符 转换单个字符 
   >> 向右缩进
   << 向左缩进
   shift k 查看这个字符的man文档（可以先属于哪一章）
   ZZ 命令模式下保存退出
   }
   编辑模式：
   a 当前光标的后面
   A 跳到当前行的尾部
   i 当前光标的前面
   I 跳到当前行的头部
   o 当前光标所在行的下面，创建新的一行
   O 当前光标所在行的上面，创建新的一行
   s 覆盖当前光标所覆盖的字符，再进行输入
   S 覆盖当前光标所覆盖的行，再进行输入
末行模式：
   （更多的是字符串的替换）
   是从命令模式跳过来的
   300  自动跳到300行
   :s/tom/jack 当前光标所在行的第一个tom替换成jack
   :s/tom/jack/g 当前光标所在行的tom替换成jack
   ：%s/tom/jack  当前文件的每一行的第一个tom被替换
   ：%s/tom/jack/g  当前文件的每一行的tom被替换
   ：27,30s/tom/jack 第27行到第30行进行替换操作
   : !pwd 当前路径
   wq 末行模式下保存退出
   
 vi分屏
   末行模式下：
   :sp 水平分屏
   :vsp 垂直分屏
     ctrl键+w+w 切换
     :wqall 保存并退出所有的
     :qall 退出所有
     :wall 保存所有
     all可以去掉
   vsp 文件名 在另外一个屏幕中打开这个文件
 vim打造IDE
   网上找（已搞好）
 系统级配置文件和用户级配置文件弄一个就行
 gcc编译的四个阶段：hello.c ->(预处理器cpp) -> c文件(hello.i)-> (编译器gcc) -> 汇编文件（hello.s）->(汇编器as)->二进制文件
 ->(连接器ID) -> 可执行文件（a.out）
(gcc.e -> gcc.s ->  gcc.c)
vim 配置文件
https://blog.csdn.net/m0_38081836/article/details/79745634
-c 只编译子程序
-E 生成二进制文件（.0 文件）
-g gdb调试的时候
-o 产生目标文件
gcc sum.c -I (路径) 指定头文件目录
gcc -D DEBUG 指定宏定义
gcc -O3 最好的代码冗余优化（可以是1,或者2或者3）
gcc -Wall 输出警告信息
-g 在程序中添加调试信息



静态库
 一，命名规则
  1.lib 库的名称  .a  静态库
   ex：lib mytest.a （名称为mytest）
 二，制作步骤
  1，生成的对应的.o文件  -c
  2，将生成的文件打包 ar rcs + 静态库的名字（libMytest.a）+  生成的所有的.o
  3，使用 gcc main.c lib/静态库的名称 -o -I(头文件) sum(目标文件)
  gcc main.c -I include -L lib -l Mycalc -o myapp
            调用哪个头文件 调用哪个静态库的目录   用哪个静态库  生成的app
  nm  libMytest.a 查看当前可执行文件下都有哪些
 三，发布和使用静态库
   1，发布静态库
   2，头文件
 四，优缺点
   优点：
    1，发布程序时不需要打包库
    2，调用时库的加载速度快
   缺点：
    1，导致库的体积大
    2，库发生改变，需要重新编译程序
动态库
对应windows中的dll文件
 .so 类型文件
 一，命名规则
  1，lib + 名字 + .so  
 二，制作步骤
  1，生成与位置无关的代码（.o）
   gcc -fPIC -c *.c 注意加目录
  2, 把.o打包成共享库（动态库） 
   gcc -shared libMyCalc.so *.o -Iinclude
 三，使用共享库
  fabuhe  把libMycalc.so发给用户
  通过ldd命令，查看可执行程序在执行时所以来的所有的库
四，动态连接器加载动态库路径的修改（开发动态库的方法，解决程序执行时动态库无法被加载的原因）
 1，
  直接修改路径（不推荐）
 2.
  通过配置额外的环境变量，LD_LIBARY_PATH
  每一次先判断库的路径，先搜索LD_LIBARY_PATH配置的环境变量的路径，然后再去找默认的.
  具体更改方法：export LD_LIBARY_PATH=相对路径 （export用于设置或者显示环境变量）
 3，
  永久设置
   进入家目录下的bashrc的最后一行修改路径（需要重启终端）
 4，
  找动态连接器的配置文件-> 动态库的路径写到配置文件中 -> 更新（sudo ldconfig -v）
  /etc/ld.so.conf        加上动态库的绝对路径          
动态库的优点：
 （静态库的缺点）
 1，体积小
 2，在函数接口不变得前提下，动态库更新不需要重新编译
动态库的缺点：
 1，发布程序时，需要将动态库提供给用户
 2，动态库没有被加载到应用程序，加载速度慢.
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
