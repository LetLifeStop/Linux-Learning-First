gdb调试
 1，启动gdb
 start  只执行一步
   n  next
   s  单步
   c 直接停在断点位置
 l 列出代码信息
 break 行数 打断点
 i break 查看断点信息
 s 进入函数体的内部
 n 单步执行
 ptype 名称 查看变量类型
 display i 追踪i的值
 info display 追踪变量的编号
 undusplay 1 停止追踪编号为1的变量的值
 u 跳出单次循环
 finish  跳出当前函数

makefile 的编写
 如果每次都是直接调用每个库的话，不仅代码量会变得冗长，还有可能耗费大量的时间；这个时候通过makelife来实现，
 对修改的子文件进行部分重新编译，不仅能降低时间，还可以减少代码量。
  项目的代码管理工具
  vi makefile {
  第一种编写格式（效率低）：
  目标文件名称: 子文件名称
         gcc 子文件名称 目标文件名称 
  如果要是提高效率的话，可以对子文件分别建立依赖
  makefile向下检索，构建一颗关系依赖树.
  具体更新的时候，是通过时间来进行判断的，对于目标生成的，如果发现他的构成的更新时间比他晚，那么就说明
他的子文件有更新，那么这个目标生成就会进行重新更新,
  makefile中的自动变量
  $<  规则中的第一个依赖 
  $@  规则中的目标
  $^  规则中的所有的依赖
  } 
  makefile中的函数都是有返回值的，并且定义的变量不需要定义类型. 
makefile中的函数使用 
  src=$(wildcard ./*.c) 获取当前目录下.c类型的文件
  obj=&(patsubst ./%.c, ./%.o,&(src)) 把当前目录下的.c（从src中取得）替换成.o
  clean:
    rm $(obj) $(target) 删掉obj和target所指向的内容
    (可以在rm前面加一个 - ,如果执行失败了，会继续往下执行；原来的会停住)
  make 直接生成终极目标；如果是后面加名称的话，就可以运行指定的文件.
  .PHONY:clean  这样的话，就不会进行时间的比较，会直接执行.
  
C库IO函数工作流程
  文件描述符 -> 索引到对应的磁盘文件
  文件读写指针位置 -> 读写文件的过程中指针的实际位置
  I/O缓冲区  -> 保存内存的地址，通过指针找到相应的内存块.
  每一次并不是读一个字符写一个字符，是先写到缓存区上，然后缓存区满了之后，
  再写入到内存.（fclose或者main中的return，或者main中exit都会把缓存区中的数据写到硬盘上）.
    
 elf段
  .bss（未初始化全局变量）  .data（已初始化全局变量） .text(代码段，二进制机器指令(代码位置))
 栈空间是从栈空间从上往下存储的；堆（new，malloc）是从堆空间分配，分配方法和堆空间是相反的.共享库的空间申请是相对地址.
 cpu为什么要使用虚拟地址空间与物理地址空间映射？解决了那些问题？
  1，方便编译器和操作系统安排程序的地址分布
   程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区
  2，方便进程之间的隔离
    不同进程使用的虚拟地址彼此隔离，一个进程中的代码无法更改正在由另一进程使用的物理内存.
  3, 方便os使用内存
    确实没有足够的内存，使用虚拟内存可以在物理内存和磁盘之间移动.
   
    
 open函数中的访问权限：777之类的..
 erron的介绍及使用
 open函数的使用
 具体查询函数如何使用的过程，可以通过man文档查看，（shift+k ，回车)
 int fd;
 fd = open("bucunzai",O_RDWR);
 fd == -1 // 发生错误
 perror("open file") // 打印错误信息
 close（fd）;关闭文件
 
    
    
